--- a/alc/voice.cpp
+++ b/alc/voice.cpp
@@ -608,32 +608,48 @@ void ALvoice::mix(const State vstate, ALCcontext *Context, const ALuint SamplesT
     do {
         /* Figure out how many buffer samples will be needed */
         ALuint DstBufferSize{SamplesToDo - OutPos};
+        ALuint SrcBufferSize;
 
-        /* Calculate the last written dst sample pos. */
-        uint64_t DataSize64{DstBufferSize - 1};
-        /* Calculate the last read src sample pos. */
-        DataSize64 = (DataSize64*increment + DataPosFrac) >> FRACTIONBITS;
-        /* +1 to get the src sample count, include padding. */
-        DataSize64 += 1 + MAX_RESAMPLER_PADDING;
-
-        auto SrcBufferSize = static_cast<ALuint>(
-            minu64(DataSize64, BUFFERSIZE + MAX_RESAMPLER_PADDING + 1));
-        if(SrcBufferSize > BUFFERSIZE + MAX_RESAMPLER_PADDING)
+        if(increment <= FRACTIONONE)
         {
-            SrcBufferSize = BUFFERSIZE + MAX_RESAMPLER_PADDING;
-            /* If the source buffer got saturated, we can't fill the desired
-             * dst size. Figure out how many samples we can actually mix from
-             * this.
-             */
-            DataSize64 = SrcBufferSize - MAX_RESAMPLER_PADDING;
-            DataSize64 = ((DataSize64<<FRACTIONBITS) - DataPosFrac + increment-1) / increment;
-            DstBufferSize = static_cast<ALuint>(minu64(DataSize64, DstBufferSize));
-
-            /* Some mixers like having a multiple of 4, so try to give that
-             * unless this is the last update.
+            /* Calculate the last written dst sample pos. */
+            uint64_t DataSize64{DstBufferSize - 1};
+            /* Calculate the last read src sample pos. */
+            DataSize64 = (DataSize64*increment + DataPosFrac) >> FRACTIONBITS;
+            /* +1 to get the src sample count, include padding. */
+            DataSize64 += 1 + MAX_RESAMPLER_PADDING;
+
+            /* Result is guaranteed to be <= BUFFERSIZE+MAX_RESAMPLER_PADDING
+             * since we won't use more src samples than dst samples+padding.
              */
-            if(DstBufferSize < SamplesToDo-OutPos)
-                DstBufferSize &= ~3u;
+            SrcBufferSize = static_cast<ALuint>(DataSize64);
+        }
+        else
+        {
+            uint64_t DataSize64{DstBufferSize};
+            /* Calculate the end src sample pos, include padding. */
+            DataSize64 = (DataSize64*increment + DataPosFrac) >> FRACTIONBITS;
+            DataSize64 += MAX_RESAMPLER_PADDING;
+
+            SrcBufferSize = static_cast<ALuint>(minu64(DataSize64,
+                BUFFERSIZE + MAX_RESAMPLER_PADDING + 1));
+            if(SrcBufferSize > BUFFERSIZE + MAX_RESAMPLER_PADDING)
+            {
+                SrcBufferSize = BUFFERSIZE + MAX_RESAMPLER_PADDING;
+                /* If the source size got saturated, we can't fill the desired
+                 * dst size. Figure out how many samples we can actually mix
+                 * from this.
+                 */
+                DataSize64 = SrcBufferSize - MAX_RESAMPLER_PADDING;
+                DataSize64 = ((DataSize64<<FRACTIONBITS) - DataPosFrac) / increment;
+                if(DataSize64 < DstBufferSize)
+                {
+                    /* Some mixers require being 16-byte aligned, so also limit
+                     * to a multiple of 4 samples to maintain alignment.
+                     */
+                    DstBufferSize = static_cast<ALuint>(DataSize64) & ~3u;
+                }
+            }
         }
 
         ASSUME(DstBufferSize > 0);
