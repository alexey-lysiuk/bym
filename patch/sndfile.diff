--- a/sndfile.pc.in
+++ b/sndfile.pc.in
@@ -7,6 +7,6 @@
 Description: A library for reading and writing audio files
 Requires: 
 Version: @VERSION@
-Libs: -L${libdir} -lsndfile
+Libs: -L${libdir} -lsndfile @EXTERNAL_XIPH_LIBS@
 Libs.private: @EXTERNAL_XIPH_LIBS@
 Cflags: -I${includedir} 

From fd0484aba8e51d16af1e3a880f9b8b857b385eb3 Mon Sep 17 00:00:00 2001
From: Erik de Castro Lopo <erikd@mega-nerd.com>
Date: Wed, 12 Apr 2017 19:45:30 +1000
Subject: [PATCH] FLAC: Fix a buffer read overrun
References: CVE-2017-8361 CVE-2017-8363 CVE-2017-8365 bsc#1036944 bsc#1036945 bsc#1036946

Buffer read overrun occurs when reading a FLAC file that switches
from 2 channels to one channel mid-stream. Only option is to
abort the read.

Closes: https://github.com/erikd/libsndfile/issues/230

---
 src/common.h  |    1 +
 src/flac.c    |   13 +++++++++++++
 src/sndfile.c |    1 +
 3 files changed, 15 insertions(+)

--- a/src/common.h
+++ b/src/common.h
@@ -725,6 +725,7 @@ enum
 	SFE_FLAC_INIT_DECODER,
 	SFE_FLAC_LOST_SYNC,
 	SFE_FLAC_BAD_SAMPLE_RATE,
+	SFE_FLAC_CHANNEL_COUNT_CHANGED,
 	SFE_FLAC_UNKOWN_ERROR,
 
 	SFE_WVE_NOT_WVE,
--- a/src/flac.c
+++ b/src/flac.c
@@ -435,6 +435,19 @@ sf_flac_meta_callback (const FLAC__Strea
 
 	switch (metadata->type)
 	{	case FLAC__METADATA_TYPE_STREAMINFO :
+			if (psf->sf.channels > 0 && psf->sf.channels != (int) metadata->data.stream_info.channels)
+			{	psf_log_printf (psf, "Error: FLAC stream changed from %d to %d channels\n"
+									"Nothing to be but to error out.\n" ,
+									psf->sf.channels, metadata->data.stream_info.channels) ;
+				psf->error = SFE_FLAC_CHANNEL_COUNT_CHANGED ;
+				return ;
+				} ;
+
+			if (psf->sf.channels > 0 && psf->sf.samplerate != (int) metadata->data.stream_info.sample_rate)
+			{	psf_log_printf (psf, "Warning: FLAC stream changed sample rates from %d to %d.\n"
+									"Carrying on as if nothing happened.",
+									psf->sf.samplerate, metadata->data.stream_info.sample_rate) ;
+				} ;
 			psf->sf.channels = metadata->data.stream_info.channels ;
 			psf->sf.samplerate = metadata->data.stream_info.sample_rate ;
 			psf->sf.frames = metadata->data.stream_info.total_samples ;
--- a/src/sndfile.c
+++ b/src/sndfile.c
@@ -245,6 +245,7 @@ ErrorStruct SndfileErrors [] =
 	{	SFE_FLAC_INIT_DECODER	, "Error : problem with initialization of the flac decoder." },
 	{	SFE_FLAC_LOST_SYNC		, "Error : flac decoder lost sync." },
 	{	SFE_FLAC_BAD_SAMPLE_RATE, "Error : flac does not support this sample rate." },
+	{	SFE_FLAC_CHANNEL_COUNT_CHANGED, "Error : flac channel changed mid stream." },
 	{	SFE_FLAC_UNKOWN_ERROR	, "Error : unknown error in flac decoder." },
 
 	{	SFE_WVE_NOT_WVE			, "Error : not a WVE file." },

From ef1dbb2df1c0e741486646de40bd638a9c4cd808 Mon Sep 17 00:00:00 2001
From: Erik de Castro Lopo <erikd@mega-nerd.com>
Date: Fri, 14 Apr 2017 15:19:16 +1000
Subject: [PATCH] src/flac.c: Fix a buffer read overflow
References: CVE-2017-8362 bsc#1036943

A file (generated by a fuzzer) which increased the number of channels
from one frame to the next could cause a read beyond the end of the
buffer provided by libFLAC. Only option is to abort the read.

Closes: https://github.com/erikd/libsndfile/issues/231

---
 src/flac.c |   11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

--- a/src/flac.c
+++ b/src/flac.c
@@ -169,6 +169,14 @@ flac_buffer_copy (SF_PRIVATE *psf)
 	const int32_t* const *buffer = pflac->wbuffer ;
 	unsigned i = 0, j, offset, channels, len ;
 
+	if (psf->sf.channels != (int) frame->header.channels)
+	{	psf_log_printf (psf, "Error: FLAC frame changed from %d to %d channels\n"
+									"Nothing to do but to error out.\n" ,
+									psf->sf.channels, frame->header.channels) ;
+		psf->error = SFE_FLAC_CHANNEL_COUNT_CHANGED ;
+		return 0 ;
+		} ;
+
 	/*
 	**	frame->header.blocksize is variable and we're using a constant blocksize
 	**	of FLAC__MAX_BLOCK_SIZE.
@@ -202,7 +210,6 @@ flac_buffer_copy (SF_PRIVATE *psf)
 		return 0 ;
 		} ;
 
-
 	len = SF_MIN (pflac->len, frame->header.blocksize) ;
 
 	if (pflac->remain % channels != 0)
@@ -437,7 +444,7 @@ sf_flac_meta_callback (const FLAC__Strea
 	{	case FLAC__METADATA_TYPE_STREAMINFO :
 			if (psf->sf.channels > 0 && psf->sf.channels != (int) metadata->data.stream_info.channels)
 			{	psf_log_printf (psf, "Error: FLAC stream changed from %d to %d channels\n"
-									"Nothing to be but to error out.\n" ,
+									"Nothing to do but to error out.\n" ,
 									psf->sf.channels, metadata->data.stream_info.channels) ;
 				psf->error = SFE_FLAC_CHANNEL_COUNT_CHANGED ;
 				return ;

From f833c53cb596e9e1792949f762e0b33661822748 Mon Sep 17 00:00:00 2001
From: Erik de Castro Lopo <erikd@mega-nerd.com>
Date: Tue, 23 May 2017 20:15:24 +1000
Subject: [PATCH] src/aiff.c: Fix a buffer read overflow

Secunia Advisory SA76717.

Found by: Laurent Delosieres, Secunia Research at Flexera Software
---
 src/aiff.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/src/aiff.c
+++ b/src/aiff.c
@@ -1905,7 +1905,7 @@ aiff_read_chanmap (SF_PRIVATE * psf, uns
 		psf_binheader_readf (psf, "j", dword - bytesread) ;
 
 	if (map_info->channel_map != NULL)
-	{	size_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;
+	{	size_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;
 
 		free (psf->channel_map) ;
 

From cf7a8182c2642c50f1cf90dddea9ce96a8bad2e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rn=20Heusipp?= <osmanx@problemloesungsmaschine.de>
Date: Wed, 14 Jun 2017 12:25:40 +0200
Subject: [PATCH] src/common.c: Fix heap buffer overflows when writing strings
 in binheader

Fixes the following problems:
 1. Case 's' only enlarges the buffer by 16 bytes instead of size bytes.
 2. psf_binheader_writef() enlarges the header buffer (if needed) prior to the
    big switch statement by an amount (16 bytes) which is enough for all cases
    where only a single value gets added. Cases 's', 'S', 'p' however
    additionally write an arbitrary length block of data and again enlarge the
    buffer to the required amount. However, the required space calculation does
    not take into account the size of the length field which gets output before
    the data.
 3. Buffer size requirement calculation in case 'S' does not account for the
    padding byte ("size += (size & 1) ;" happens after the calculation which
    uses "size").
 4. Case 'S' can overrun the header buffer by 1 byte when no padding is
    involved
    ("memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;" while
    the buffer is only guaranteed to have "size" space available).
 5. "psf->header.ptr [psf->header.indx] = 0 ;" in case 'S' always writes 1 byte
    beyond the space which is guaranteed to be allocated in the header buffer.
 6. Case 's' can overrun the provided source string by 1 byte if padding is
    involved ("memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;"
    where "size" is "strlen (strptr) + 1" (which includes the 0 terminator,
    plus optionally another 1 which is padding and not guaranteed to be
    readable via the source string pointer).

Closes: https://github.com/erikd/libsndfile/issues/292
---
 src/common.c |   15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

--- a/src/common.c
+++ b/src/common.c
@@ -675,16 +675,16 @@ psf_binheader_writef (SF_PRIVATE *psf, c
 					/* Write a C string (guaranteed to have a zero terminator). */
 					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) + 1 ;
-					size += (size & 1) ;
 
-					if (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))
+					if (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))
 						return count ;
 
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
-						header_put_be_int (psf, size) ;
+						header_put_be_int (psf, size + (size & 1)) ;
 					else
-						header_put_le_int (psf, size) ;
+						header_put_le_int (psf, size + (size & 1)) ;
 					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
+					size += (size & 1) ;
 					psf->header.indx += size ;
 					psf->header.ptr [psf->header.indx - 1] = 0 ;
 					count += 4 + size ;
@@ -697,16 +697,15 @@ psf_binheader_writef (SF_PRIVATE *psf, c
 					*/
 					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) ;
-					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
+					if (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))
 						return count ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						header_put_be_int (psf, size) ;
 					else
 						header_put_le_int (psf, size) ;
-					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;
+					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + (size & 1)) ;
 					size += (size & 1) ;
 					psf->header.indx += size ;
-					psf->header.ptr [psf->header.indx] = 0 ;
 					count += 4 + size ;
 					break ;
 
@@ -718,7 +717,7 @@ psf_binheader_writef (SF_PRIVATE *psf, c
 					size = (size & 1) ? size : size + 1 ;
 					size = (size > 254) ? 254 : size ;
 
-					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
+					if (psf->header.indx + 1 + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, 1 + size))
 						return count ;
 
 					header_put_byte (psf, size) ;

From 85c877d5072866aadbe8ed0c3e0590fbb5e16788 Mon Sep 17 00:00:00 2001
From: Fabian Greffrath <fabian@greffrath.com>
Date: Thu, 28 Sep 2017 12:15:04 +0200
Subject: [PATCH] double64_init: Check psf->sf.channels against upper bound

This prevents division by zero later in the code.

While the trivial case to catch this (i.e. sf.channels < 1) has already
been covered, a crafted file may report a number of channels that is
so high (i.e. > INT_MAX/sizeof(double)) that it "somehow" gets
miscalculated to zero (if this makes sense) in the determination of the
blockwidth. Since we only support a limited number of channels anyway,
make sure to check here as well.

CVE-2017-14634

Closes: https://github.com/erikd/libsndfile/issues/318
Signed-off-by: Erik de Castro Lopo <erikd@mega-nerd.com>
---
 src/double64.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/src/double64.c
+++ b/src/double64.c
@@ -91,7 +91,7 @@ int
 double64_init	(SF_PRIVATE *psf)
 {	static int double64_caps ;
 
-	if (psf->sf.channels < 1)
+	if (psf->sf.channels < 1 || psf->sf.channels > SF_MAX_CHANNELS)
 	{	psf_log_printf (psf, "double64_init : internal error : channels = %d\n", psf->sf.channels) ;
 		return SFE_INTERNAL ;
 		} ;

From 2d54514a4f6437b67829717c05472d2e3300a258 Mon Sep 17 00:00:00 2001
From: Fabian Greffrath <fabian@greffrath.com>
Date: Wed, 27 Sep 2017 14:46:17 +0200
Subject: [PATCH] sfe_copy_data_fp: check value of "max" variable for being
 normal

and check elements of the data[] array for being finite.

Both checks use functions provided by the <math.h> header as declared
by the C99 standard.

Fixes #317
CVE-2017-14245
CVE-2017-14246
---
 programs/common.c          |   20 ++++++++++++++++----
 programs/common.h          |    2 +-
 programs/sndfile-convert.c |    6 +++++-
 3 files changed, 22 insertions(+), 6 deletions(-)

--- a/programs/common.c
+++ b/programs/common.c
@@ -36,6 +36,7 @@
 #include <string.h>
 #include <ctype.h>
 #include <stdint.h>
+#include <math.h>
 
 #include <sndfile.h>
 
@@ -45,7 +46,7 @@
 
 #define	MIN(x, y)	((x) < (y) ? (x) : (y))
 
-void
+int
 sfe_copy_data_fp (SNDFILE *outfile, SNDFILE *infile, int channels, int normalize)
 {	static double	data [BUFFER_LEN], max ;
 	int		frames, readcount, k ;
@@ -54,6 +55,8 @@ sfe_copy_data_fp (SNDFILE *outfile, SNDF
 	readcount = frames ;
 
 	sf_command (infile, SFC_CALC_SIGNAL_MAX, &max, sizeof (max)) ;
+	if (!isnormal (max)) /* neither zero, subnormal, infinite, nor NaN */
+		return 1 ;
 
 	if (!normalize && max < 1.0)
 	{	while (readcount > 0)
@@ -67,12 +70,16 @@ sfe_copy_data_fp (SNDFILE *outfile, SNDF
 		while (readcount > 0)
 		{	readcount = sf_readf_double (infile, data, frames) ;
 			for (k = 0 ; k < readcount * channels ; k++)
-				data [k] /= max ;
+			{	data [k] /= max ;
+
+				if (!isfinite (data [k])) /* infinite or NaN */
+					return 1;
+				}
 			sf_writef_double (outfile, data, readcount) ;
 			} ;
 		} ;
 
-	return ;
+	return 0 ;
 } /* sfe_copy_data_fp */
 
 void
@@ -252,7 +259,12 @@ sfe_apply_metadata_changes (const char *
 
 		/* If the input file is not the same as the output file, copy the data. */
 		if ((infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT))
-			sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) ;
+		{	if (sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) != 0)
+			{	printf ("Error : Not able to decode input file '%s'\n", filenames [0]) ;
+				error_code = 1 ;
+				goto cleanup_exit ;
+				} ;
+			}
 		else
 			sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
 		} ;
--- a/programs/common.h
+++ b/programs/common.h
@@ -62,7 +62,7 @@ typedef SF_BROADCAST_INFO_VAR (2048) SF_
 
 void sfe_apply_metadata_changes (const char * filenames [2], const METADATA_INFO * info) ;
 
-void sfe_copy_data_fp (SNDFILE *outfile, SNDFILE *infile, int channels, int normalize) ;
+int sfe_copy_data_fp (SNDFILE *outfile, SNDFILE *infile, int channels, int normalize) ;
 
 void sfe_copy_data_int (SNDFILE *outfile, SNDFILE *infile, int channels) ;
 
--- a/programs/sndfile-convert.c
+++ b/programs/sndfile-convert.c
@@ -335,7 +335,11 @@ main (int argc, char * argv [])
 			|| (outfileminor == SF_FORMAT_DOUBLE) || (outfileminor == SF_FORMAT_FLOAT)
 			|| (infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT)
 			|| (infileminor == SF_FORMAT_VORBIS) || (outfileminor == SF_FORMAT_VORBIS))
-		sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) ;
+	{	if (sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) != 0)
+		{	printf ("Error : Not able to decode input file %s.\n", infilename) ;
+			return 1 ;
+			} ;
+		}
 	else
 		sfe_copy_data_int (outfile, infile, sfinfo.channels) ;
 
---
 src/alaw.c |   36 ++++++++++++++++++++++++++++--------
 1 file changed, 28 insertions(+), 8 deletions(-)

--- a/src/alaw.c
+++ b/src/alaw.c
@@ -336,20 +336,40 @@ i2alaw_array (const int *ptr, int count,
 static inline void
 f2alaw_array (const float *ptr, int count, unsigned char *buffer, float normfact)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
-			buffer [count] = alaw_encode [lrintf (normfact * ptr [count])] ;
-		else
-			buffer [count] = 0x7F & alaw_encode [- lrintf (normfact * ptr [count])] ;
+	{	int idx;
+		if (isnan (ptr [count])) {
+			buffer [count] = alaw_encode [0] ;
+		} else if (ptr [count] >= 0) {
+			idx = lrintf (normfact * ptr [count]) ;
+			if (idx > 2048)
+				idx = 2048;
+			buffer [count] = alaw_encode [idx] ;
+		} else {
+			idx = -lrintf (normfact * ptr [count]) ;
+			if (idx > 2048)
+				idx = 2048 ;
+			buffer [count] = 0x7F & alaw_encode [idx] ;
+			}
 		} ;
 } /* f2alaw_array */
 
 static inline void
 d2alaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
-			buffer [count] = alaw_encode [lrint (normfact * ptr [count])] ;
-		else
-			buffer [count] = 0x7F & alaw_encode [- lrint (normfact * ptr [count])] ;
+	{	int idx;
+		if (isnan (ptr [count])) {
+			buffer [count] = alaw_encode [0] ;
+		} else if (ptr [count] >= 0) {
+			idx = lrintf (normfact * ptr [count]) ;
+			if (idx > 2048)
+				idx = 2048;
+			buffer [count] = alaw_encode [idx] ;
+		} else {
+			idx = -lrintf (normfact * ptr [count]) ;
+			if (idx > 2048)
+				idx = 2048 ;
+			buffer [count] = 0x7F & alaw_encode [idx] ;
+			}
 		} ;
 } /* d2alaw_array */
 

---
 src/ulaw.c |   36 ++++++++++++++++++++++++++++--------
 1 file changed, 28 insertions(+), 8 deletions(-)

--- a/src/ulaw.c
+++ b/src/ulaw.c
@@ -837,20 +837,40 @@ i2ulaw_array (const int *ptr, int count,
 static inline void
 f2ulaw_array (const float *ptr, int count, unsigned char *buffer, float normfact)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
-			buffer [count] = ulaw_encode [lrintf (normfact * ptr [count])] ;
-		else
-			buffer [count] = 0x7F & ulaw_encode [- lrintf (normfact * ptr [count])] ;
+	{	int idx;
+		if (isnan (ptr [count])) {
+			buffer [count] = ulaw_encode [0];
+		} else if (ptr [count] >= 0) {
+			idx = lrint (normfact * ptr [count]);
+			if (idx > 8192)
+				idx = 8192;
+			buffer [count] = ulaw_encode [idx] ;
+		} else {
+			idx = -lrint (normfact * ptr [count]) ;
+			if (idx > 8192)
+				idx = 8192;
+			buffer [count] = 0x7F & ulaw_encode [idx] ;
+			}
 		} ;
 } /* f2ulaw_array */
 
 static inline void
 d2ulaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
-			buffer [count] = ulaw_encode [lrint (normfact * ptr [count])] ;
-		else
-			buffer [count] = 0x7F & ulaw_encode [- lrint (normfact * ptr [count])] ;
+	{	int idx;
+		if (isnan (ptr [count])) {
+			buffer [count] = ulaw_encode [0];
+		} else if (ptr [count] >= 0) {
+			idx = lrint (normfact * ptr [count]);
+			if (idx > 8192)
+				idx = 8192;
+			buffer [count] = ulaw_encode [idx] ;
+		} else {
+			idx = -lrint (normfact * ptr [count]) ;
+			if (idx > 8192)
+				idx = 8192;
+			buffer [count] = 0x7F & ulaw_encode [idx] ;
+			}
 		} ;
 } /* d2ulaw_array */
 

diff --git a/programs/sndfile-deinterleave.c b/programs/sndfile-deinterleave.c
index 5366031075ab..712cb96cda76 100644
--- a/programs/sndfile-deinterleave.c
+++ b/programs/sndfile-deinterleave.c
@@ -89,6 +89,11 @@ main (int argc, char **argv)
 		exit (1) ;
 		} ;
 
+	if (sfinfo.channels > MAX_CHANNELS)
+	{	printf ("\nError : Too many channels %d in input file '%s'.\n", sfinfo.channels, argv[1]) ;
+		exit (1) ;
+		}
+
 	state.channels = sfinfo.channels ;
 	sfinfo.channels = 1 ;
 

---
 src/file_io.c |    3 +++
 1 file changed, 3 insertions(+)

--- a/src/file_io.c
+++ b/src/file_io.c
@@ -570,6 +570,9 @@ psf_open_fd (PSF_FILE * pfile)
 				return - SFE_BAD_OPEN_MODE ;
 				break ;
 		} ;
+#ifdef O_CLOEXEC
+        oflag |= O_CLOEXEC;
+#endif
 
 	if (mode == 0)
 		fd = open (pfile->path.c, oflag) ;
